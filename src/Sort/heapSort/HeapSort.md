# 优先队列，堆，堆排序
## 1.优先队列
### 1.1 出队顺序
- 普通队列：先进先出，后进后出
- 优先队列：出队顺序与入队无关，与优先级相关。
### 1.2 应用场景
- 计算机操作系统动态选择优先级较高的任务执行
- 游戏AI自动选择要攻击的敌人
- 排序时因内存限制无法一次性加载所有数据

### 1.3  优先队列的实现
接口不变
```
public interface Queues<E> {
    int getSize();
    boolean isEmpty();
    void enqueue(E e);
    E dequeue();
    E getFront();
}
```
区别在于 出队与查看队首的逻辑

|              | 入队        | 出队        |
| ------------ | ----------- | ----------- |
| 普通线性结构 | O(1)        | O(N)        |
| 顺序线性结构 | O(N)        | O(1)        |
| 堆           | 最差O(logN) | 最差O(logN) |

使用堆作为优先队列的底层实现，使其入队/出队变成对数级别。

### 1.3 二叉堆 Binary Heap

**二叉堆**：以二叉树来实现一个堆，是一颗完全二叉树	（除了叶子节点，左右孩子都不为空，
InOtherWords，不是满二叉树，缺失节点在右下方，把元素从左到右排列成树的形状）。
按照节点的值与其父节点的大小分为最大堆（堆中某个节点的值总是不大于其父节点的值），最小堆（相应的不小于）。

用数组存储二叉堆时，

索引从1开始时满足：

- parent(i) = i / 2； 

- left_Child = i\*2; 

-  right_Child = I\*2 + 1 

索引从0开始：

- parent(i) = (i-1) / 2； 
- left_Child = i\*2 + 1; 
-  right_Child = I\*2 + 2;

#### 代码实现
使用动态数组来实现一个最大堆  链接
siftUp逻辑
先将元素addLast到末尾，然后，分别与其父节点进行比较，如果比父节点大，那么二者交换位置，循环往复，直到遇到比其大的父节点
就停止，形象的类似于"上浮"的操作

siftDown逻辑：
siftDown的逻辑是先将数组最后一个元素放到堆顶，这样确保 完全二叉树的性质不变。然后再siftDown，依次看与子节点中最大的值比较，
如果比它大，二者交换位置，类似于"下沉"操作

使用Heapify会比一个一个加入到堆中快一倍，即O(n)级别的操作，快于 O(nlogn)

原地堆排序的算法
使用Heapify的思想，将一个数组变成一个最大堆，那么index=0就是最大值，与数组尾部元素调换。
接着在[0,arr.length-2]继续以上操作。

堆排序 优化后的结果，时间复杂度是对于小数据 O(n) 和 O(nlog)差别并不大，但是空间复杂度是O(1)级别的。

